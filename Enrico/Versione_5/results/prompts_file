
### ANSWER PROMPT ###

    You are a helpful smart assistant.
    You'll receive the results of the query, written in Cypher language: explain these results in a natural way.
    Please, be synthetic: read the results and explain them by answering to the user question.  
    

 # QUESTION PROMPT 
    You are an expert Cypher generator: your task is to generate Cypher query that best answers the user question.
    
    Follow these guidelines:
    
    1. Always output a syntactically correct Cypher query and nothing else. 
    2. Use only the node labels, relationship types, and property keys provided in the schema.
    3. Use specific names only if explicitly mentioned in the question.
    4. Do not invent properties or overly specific details.
    5. Keep queries syntactically correct, simple, and readable.
    6. Access node properties using dot notation (e.g., `n.name`).
    
    
Here's the database schema:

These are values for the 'name' property
- Television_1
- Occupancy_sensor_4
- Occupancy_sensor_5
- Occupancy_sensor_2
- Washing_machine_1
- Occupancy_sensor_3
- Occupancy_sensor_1
- Study
- Temperature_sensor_1
- Ceiling_light_3
- Ceiling_light_2
- Ceiling_light_5
- Ceiling_light_4
- Ceiling_light_1
- Humidity_sensor_1
- Coffee_machine_1
- Lamp_1
- Kitchen
- Oven_1
- Bedroom
- Brightness_sensor_1
- Lamp_3
- Lamp_2
- Air_conditioner_1
- Air_conditioner_2
- Bathroom
- Smoke_sensor_1
- Robot_vacuum_1
- Living_room

Each label has these properties
Label: `NamedIndividual` has ONLY these properties: ['name', 'setting', 'state', 'unit', 'value']
Label: `Room` has ONLY these properties: ['name']
Label: `Class` has ONLY these properties: ['name']

Examples per Label
Examples for `NamedIndividual` -> ['Bathroom', 'Bedroom', 'Living_room', 'Robot_vacuum_1', 'Smoke_sensor_1']
Examples for `Room` -> ['Bathroom', 'Bedroom', 'Kitchen', 'Living_room', 'Study']
Examples for `Class` -> ['Appliance', 'Boolean_sensor', 'Dimmable_light', 'Robot_vacuum', 'Sensor']

Here are all the available classes
- Light
- Categorical_sensor
- Humidity_sensor
- Air_conditioner
- Oven
- Coffee_machine
- Washing_machine
- Room
- Settable_device
- Temperature_sensor
- Numeric_sensor
- Device
- Occupancy_sensor
- Brightness_sensor
- Smoke_sensor
- Appliance
- Dimmable_light
- Togglable_device
- Robot_vacuum
- Boolean_sensor
- Television
- Sensor

These are the relationship types per labels
- (:Class)-[:SUBCLASSOF]->(:Class)
- (:NamedIndividual)-[:MEMBEROF]->(:Class)
- (:NamedIndividual)-[:LOCATED_IN]->(:NamedIndividual)
- (:Room)-[:CONTAINS]->(:NamedIndividual)
- (:NamedIndividual)-[:LOCATED_IN]->(:Room)
- (:NamedIndividual)-[:CONTAINS]->(:NamedIndividual)

### CHAT HISTORY ### 


You are a helpful assistant.

Which people live in Paris?

MATCH (p:Person)-[:LIVES_IN]->(c:City {name: 'Paris'}) RETURN p.name

Which books were published after the year 2000?

MATCH (b:Book) WHERE b.year > 2000 RETURN b.title

Who are the friends of John?

MATCH (p:Person {name: 'John'})-[:FRIEND_OF]-(f:Person) RETURN f.name

Which resources are related to something containing the word climate?

MATCH (r:Resource)-[:RELATED_TO]->(t:Topic) WHERE t.uri CONTAINS 'climate' RETURN r

Which employees work for companies based in Germany?

MATCH (e:Person)-[:WORKS_AT]->(c:Company)-[:BASED_IN]->(:Country {name: 'Germany'}) RETURN e.name


    You are an expert Cypher generator: your task is to generate Cypher query that best answers the user question.
    
    Follow these guidelines:
    
    1. Always output a syntactically correct Cypher query and nothing else. 
    2. Use only the node labels, relationship types, and property keys provided in the schema.
    3. Use specific names only if explicitly mentioned in the question.
    4. Do not invent properties or overly specific details.
    5. Keep queries syntactically correct, simple, and readable.
    6. Access node properties using dot notation (e.g., `n.name`).
    
    
Here's the database schema:

These are values for the 'name' property
- Television_1
- Occupancy_sensor_4
- Occupancy_sensor_5
- Occupancy_sensor_2
- Washing_machine_1
- Occupancy_sensor_3
- Occupancy_sensor_1
- Study
- Temperature_sensor_1
- Ceiling_light_3
- Ceiling_light_2
- Ceiling_light_5
- Ceiling_light_4
- Ceiling_light_1
- Humidity_sensor_1
- Coffee_machine_1
- Lamp_1
- Kitchen
- Oven_1
- Bedroom
- Brightness_sensor_1
- Lamp_3
- Lamp_2
- Air_conditioner_1
- Air_conditioner_2
- Bathroom
- Smoke_sensor_1
- Robot_vacuum_1
- Living_room

Each label has these properties
Label: `NamedIndividual` has ONLY these properties: ['name', 'setting', 'state', 'unit', 'value']
Label: `Room` has ONLY these properties: ['name']
Label: `Class` has ONLY these properties: ['name']

Examples per Label
Examples for `NamedIndividual` -> ['Bathroom', 'Bedroom', 'Living_room', 'Robot_vacuum_1', 'Smoke_sensor_1']
Examples for `Room` -> ['Bathroom', 'Bedroom', 'Kitchen', 'Living_room', 'Study']
Examples for `Class` -> ['Appliance', 'Boolean_sensor', 'Dimmable_light', 'Robot_vacuum', 'Sensor']

Here are all the available classes
- Light
- Categorical_sensor
- Humidity_sensor
- Air_conditioner
- Oven
- Coffee_machine
- Washing_machine
- Room
- Settable_device
- Temperature_sensor
- Numeric_sensor
- Device
- Occupancy_sensor
- Brightness_sensor
- Smoke_sensor
- Appliance
- Dimmable_light
- Togglable_device
- Robot_vacuum
- Boolean_sensor
- Television
- Sensor

These are the relationship types per labels
- (:Class)-[:SUBCLASSOF]->(:Class)
- (:NamedIndividual)-[:MEMBEROF]->(:Class)
- (:NamedIndividual)-[:LOCATED_IN]->(:NamedIndividual)
- (:Room)-[:CONTAINS]->(:NamedIndividual)
- (:NamedIndividual)-[:LOCATED_IN]->(:Room)
- (:NamedIndividual)-[:CONTAINS]->(:NamedIndividual)

where is the ceiling lamp 5? 

 # QUESTION PROMPT 
    You are an expert Cypher generator: your task is to generate Cypher query that best answers the user question.
    
    Follow these guidelines:
    
    1. Always output a syntactically correct Cypher query and nothing else. 
    2. Use only the node labels, relationship types, and property keys provided in the schema.
    3. Use specific names only if explicitly mentioned in the question.
    4. Do not invent properties or overly specific details.
    5. Keep queries syntactically correct, simple, and readable.
    6. Access node properties using dot notation (e.g., `n.name`).
    
    
Here's the database schema:

These are values for the 'name' property
- Television_1
- Occupancy_sensor_4
- Occupancy_sensor_5
- Occupancy_sensor_2
- Washing_machine_1
- Occupancy_sensor_3
- Occupancy_sensor_1
- Study
- Temperature_sensor_1
- Ceiling_light_3
- Ceiling_light_2
- Ceiling_light_5
- Ceiling_light_4
- Ceiling_light_1
- Humidity_sensor_1
- Coffee_machine_1
- Lamp_1
- Kitchen
- Oven_1
- Bedroom
- Brightness_sensor_1
- Lamp_3
- Lamp_2
- Air_conditioner_1
- Air_conditioner_2
- Bathroom
- Smoke_sensor_1
- Robot_vacuum_1
- Living_room

Each label has these properties
Label: `NamedIndividual` has ONLY these properties: ['name', 'setting', 'state', 'unit', 'value']
Label: `Room` has ONLY these properties: ['name']
Label: `Class` has ONLY these properties: ['name']

Examples per Label
Examples for `NamedIndividual` -> ['Bathroom', 'Bedroom', 'Living_room', 'Robot_vacuum_1', 'Smoke_sensor_1']
Examples for `Room` -> ['Bathroom', 'Bedroom', 'Kitchen', 'Living_room', 'Study']
Examples for `Class` -> ['Appliance', 'Boolean_sensor', 'Dimmable_light', 'Robot_vacuum', 'Sensor']

Here are all the available classes
- Light
- Categorical_sensor
- Humidity_sensor
- Air_conditioner
- Oven
- Coffee_machine
- Washing_machine
- Room
- Settable_device
- Temperature_sensor
- Numeric_sensor
- Device
- Occupancy_sensor
- Brightness_sensor
- Smoke_sensor
- Appliance
- Dimmable_light
- Togglable_device
- Robot_vacuum
- Boolean_sensor
- Television
- Sensor

These are the relationship types per labels
- (:Class)-[:SUBCLASSOF]->(:Class)
- (:NamedIndividual)-[:MEMBEROF]->(:Class)
- (:NamedIndividual)-[:LOCATED_IN]->(:NamedIndividual)
- (:Room)-[:CONTAINS]->(:NamedIndividual)
- (:NamedIndividual)-[:LOCATED_IN]->(:Room)
- (:NamedIndividual)-[:CONTAINS]->(:NamedIndividual)

### CHAT HISTORY ### 


You are a helpful assistant.

Which people live in Paris?

MATCH (p:Person)-[:LIVES_IN]->(c:City {name: 'Paris'}) RETURN p.name

Which books were published after the year 2000?

MATCH (b:Book) WHERE b.year > 2000 RETURN b.title

Who are the friends of John?

MATCH (p:Person {name: 'John'})-[:FRIEND_OF]-(f:Person) RETURN f.name

Which resources are related to something containing the word climate?

MATCH (r:Resource)-[:RELATED_TO]->(t:Topic) WHERE t.uri CONTAINS 'climate' RETURN r

Which employees work for companies based in Germany?

MATCH (e:Person)-[:WORKS_AT]->(c:Company)-[:BASED_IN]->(:Country {name: 'Germany'}) RETURN e.name


    You are an expert Cypher generator: your task is to generate Cypher query that best answers the user question.
    
    Follow these guidelines:
    
    1. Always output a syntactically correct Cypher query and nothing else. 
    2. Use only the node labels, relationship types, and property keys provided in the schema.
    3. Use specific names only if explicitly mentioned in the question.
    4. Do not invent properties or overly specific details.
    5. Keep queries syntactically correct, simple, and readable.
    6. Access node properties using dot notation (e.g., `n.name`).
    
    
Here's the database schema:

These are values for the 'name' property
- Television_1
- Occupancy_sensor_4
- Occupancy_sensor_5
- Occupancy_sensor_2
- Washing_machine_1
- Occupancy_sensor_3
- Occupancy_sensor_1
- Study
- Temperature_sensor_1
- Ceiling_light_3
- Ceiling_light_2
- Ceiling_light_5
- Ceiling_light_4
- Ceiling_light_1
- Humidity_sensor_1
- Coffee_machine_1
- Lamp_1
- Kitchen
- Oven_1
- Bedroom
- Brightness_sensor_1
- Lamp_3
- Lamp_2
- Air_conditioner_1
- Air_conditioner_2
- Bathroom
- Smoke_sensor_1
- Robot_vacuum_1
- Living_room

Each label has these properties
Label: `NamedIndividual` has ONLY these properties: ['name', 'setting', 'state', 'unit', 'value']
Label: `Room` has ONLY these properties: ['name']
Label: `Class` has ONLY these properties: ['name']

Examples per Label
Examples for `NamedIndividual` -> ['Bathroom', 'Bedroom', 'Living_room', 'Robot_vacuum_1', 'Smoke_sensor_1']
Examples for `Room` -> ['Bathroom', 'Bedroom', 'Kitchen', 'Living_room', 'Study']
Examples for `Class` -> ['Appliance', 'Boolean_sensor', 'Dimmable_light', 'Robot_vacuum', 'Sensor']

Here are all the available classes
- Light
- Categorical_sensor
- Humidity_sensor
- Air_conditioner
- Oven
- Coffee_machine
- Washing_machine
- Room
- Settable_device
- Temperature_sensor
- Numeric_sensor
- Device
- Occupancy_sensor
- Brightness_sensor
- Smoke_sensor
- Appliance
- Dimmable_light
- Togglable_device
- Robot_vacuum
- Boolean_sensor
- Television
- Sensor

These are the relationship types per labels
- (:Class)-[:SUBCLASSOF]->(:Class)
- (:NamedIndividual)-[:MEMBEROF]->(:Class)
- (:NamedIndividual)-[:LOCATED_IN]->(:NamedIndividual)
- (:Room)-[:CONTAINS]->(:NamedIndividual)
- (:NamedIndividual)-[:LOCATED_IN]->(:Room)
- (:NamedIndividual)-[:CONTAINS]->(:NamedIndividual)

where is the ceiling lamp 5? 


    You are a helpful smart assistant.
    You'll receive the results of the query, written in Cypher language: explain these results in a natural way.
    Please, be synthetic: read the results and explain them by answering to the user question.  
    

Comment the results of the Cypher query, in natural language: 
Original user question: "where is the ceiling lamp 5? "
Result from Neo4j: [{'r.name': 'Living_room'}]


    You are an expert Cypher generator: your task is to generate Cypher query that best answers the user question.
    
    Follow these guidelines:
    
    1. Always output a syntactically correct Cypher query and nothing else. 
    2. Use only the node labels, relationship types, and property keys provided in the schema.
    3. Use specific names only if explicitly mentioned in the question.
    4. Do not invent properties or overly specific details.
    5. Keep queries syntactically correct, simple, and readable.
    6. Access node properties using dot notation (e.g., `n.name`).
    
    
Here's the database schema:

These are values for the 'name' property
- Television_1
- Occupancy_sensor_4
- Occupancy_sensor_5
- Occupancy_sensor_2
- Washing_machine_1
- Occupancy_sensor_3
- Occupancy_sensor_1
- Study
- Temperature_sensor_1
- Ceiling_light_3
- Ceiling_light_2
- Ceiling_light_5
- Ceiling_light_4
- Ceiling_light_1
- Humidity_sensor_1
- Coffee_machine_1
- Lamp_1
- Kitchen
- Oven_1
- Bedroom
- Brightness_sensor_1
- Lamp_3
- Lamp_2
- Air_conditioner_1
- Air_conditioner_2
- Bathroom
- Smoke_sensor_1
- Robot_vacuum_1
- Living_room

Each label has these properties
Label: `NamedIndividual` has ONLY these properties: ['name', 'setting', 'state', 'unit', 'value']
Label: `Room` has ONLY these properties: ['name']
Label: `Class` has ONLY these properties: ['name']

Examples per Label
Examples for `NamedIndividual` -> ['Bathroom', 'Bedroom', 'Living_room', 'Robot_vacuum_1', 'Smoke_sensor_1']
Examples for `Room` -> ['Bathroom', 'Bedroom', 'Kitchen', 'Living_room', 'Study']
Examples for `Class` -> ['Appliance', 'Boolean_sensor', 'Dimmable_light', 'Robot_vacuum', 'Sensor']

Here are all the available classes
- Light
- Categorical_sensor
- Humidity_sensor
- Air_conditioner
- Oven
- Coffee_machine
- Washing_machine
- Room
- Settable_device
- Temperature_sensor
- Numeric_sensor
- Device
- Occupancy_sensor
- Brightness_sensor
- Smoke_sensor
- Appliance
- Dimmable_light
- Togglable_device
- Robot_vacuum
- Boolean_sensor
- Television
- Sensor

These are the relationship types per labels
- (:Class)-[:SUBCLASSOF]->(:Class)
- (:NamedIndividual)-[:MEMBEROF]->(:Class)
- (:NamedIndividual)-[:LOCATED_IN]->(:NamedIndividual)
- (:Room)-[:CONTAINS]->(:NamedIndividual)
- (:NamedIndividual)-[:LOCATED_IN]->(:Room)
- (:NamedIndividual)-[:CONTAINS]->(:NamedIndividual)

Check the temperature setting of all air conditioners.

 # QUESTION PROMPT 
    You are an expert Cypher generator: your task is to generate Cypher query that best answers the user question.
    
    Follow these guidelines:
    
    1. Always output a syntactically correct Cypher query and nothing else. 
    2. Use only the node labels, relationship types, and property keys provided in the schema.
    3. Use specific names only if explicitly mentioned in the question.
    4. Do not invent properties or overly specific details.
    5. Keep queries syntactically correct, simple, and readable.
    6. Access node properties using dot notation (e.g., `n.name`).
    
    
Here's the database schema:

These are values for the 'name' property
- Television_1
- Occupancy_sensor_4
- Occupancy_sensor_5
- Occupancy_sensor_2
- Washing_machine_1
- Occupancy_sensor_3
- Occupancy_sensor_1
- Study
- Temperature_sensor_1
- Ceiling_light_3
- Ceiling_light_2
- Ceiling_light_5
- Ceiling_light_4
- Ceiling_light_1
- Humidity_sensor_1
- Coffee_machine_1
- Lamp_1
- Kitchen
- Oven_1
- Bedroom
- Brightness_sensor_1
- Lamp_3
- Lamp_2
- Air_conditioner_1
- Air_conditioner_2
- Bathroom
- Smoke_sensor_1
- Robot_vacuum_1
- Living_room

Each label has these properties
Label: `NamedIndividual` has ONLY these properties: ['name', 'setting', 'state', 'unit', 'value']
Label: `Room` has ONLY these properties: ['name']
Label: `Class` has ONLY these properties: ['name']

Examples per Label
Examples for `NamedIndividual` -> ['Bathroom', 'Bedroom', 'Living_room', 'Robot_vacuum_1', 'Smoke_sensor_1']
Examples for `Room` -> ['Bathroom', 'Bedroom', 'Kitchen', 'Living_room', 'Study']
Examples for `Class` -> ['Appliance', 'Boolean_sensor', 'Dimmable_light', 'Robot_vacuum', 'Sensor']

Here are all the available classes
- Light
- Categorical_sensor
- Humidity_sensor
- Air_conditioner
- Oven
- Coffee_machine
- Washing_machine
- Room
- Settable_device
- Temperature_sensor
- Numeric_sensor
- Device
- Occupancy_sensor
- Brightness_sensor
- Smoke_sensor
- Appliance
- Dimmable_light
- Togglable_device
- Robot_vacuum
- Boolean_sensor
- Television
- Sensor

These are the relationship types per labels
- (:Class)-[:SUBCLASSOF]->(:Class)
- (:NamedIndividual)-[:MEMBEROF]->(:Class)
- (:NamedIndividual)-[:LOCATED_IN]->(:NamedIndividual)
- (:Room)-[:CONTAINS]->(:NamedIndividual)
- (:NamedIndividual)-[:LOCATED_IN]->(:Room)
- (:NamedIndividual)-[:CONTAINS]->(:NamedIndividual)

### CHAT HISTORY ### 


You are a helpful assistant.

Which people live in Paris?

MATCH (p:Person)-[:LIVES_IN]->(c:City {name: 'Paris'}) RETURN p.name

Which books were published after the year 2000?

MATCH (b:Book) WHERE b.year > 2000 RETURN b.title

Who are the friends of John?

MATCH (p:Person {name: 'John'})-[:FRIEND_OF]-(f:Person) RETURN f.name

Which resources are related to something containing the word climate?

MATCH (r:Resource)-[:RELATED_TO]->(t:Topic) WHERE t.uri CONTAINS 'climate' RETURN r

Which employees work for companies based in Germany?

MATCH (e:Person)-[:WORKS_AT]->(c:Company)-[:BASED_IN]->(:Country {name: 'Germany'}) RETURN e.name


    You are an expert Cypher generator: your task is to generate Cypher query that best answers the user question.
    
    Follow these guidelines:
    
    1. Always output a syntactically correct Cypher query and nothing else. 
    2. Use only the node labels, relationship types, and property keys provided in the schema.
    3. Use specific names only if explicitly mentioned in the question.
    4. Do not invent properties or overly specific details.
    5. Keep queries syntactically correct, simple, and readable.
    6. Access node properties using dot notation (e.g., `n.name`).
    
    
Here's the database schema:

These are values for the 'name' property
- Television_1
- Occupancy_sensor_4
- Occupancy_sensor_5
- Occupancy_sensor_2
- Washing_machine_1
- Occupancy_sensor_3
- Occupancy_sensor_1
- Study
- Temperature_sensor_1
- Ceiling_light_3
- Ceiling_light_2
- Ceiling_light_5
- Ceiling_light_4
- Ceiling_light_1
- Humidity_sensor_1
- Coffee_machine_1
- Lamp_1
- Kitchen
- Oven_1
- Bedroom
- Brightness_sensor_1
- Lamp_3
- Lamp_2
- Air_conditioner_1
- Air_conditioner_2
- Bathroom
- Smoke_sensor_1
- Robot_vacuum_1
- Living_room

Each label has these properties
Label: `NamedIndividual` has ONLY these properties: ['name', 'setting', 'state', 'unit', 'value']
Label: `Room` has ONLY these properties: ['name']
Label: `Class` has ONLY these properties: ['name']

Examples per Label
Examples for `NamedIndividual` -> ['Bathroom', 'Bedroom', 'Living_room', 'Robot_vacuum_1', 'Smoke_sensor_1']
Examples for `Room` -> ['Bathroom', 'Bedroom', 'Kitchen', 'Living_room', 'Study']
Examples for `Class` -> ['Appliance', 'Boolean_sensor', 'Dimmable_light', 'Robot_vacuum', 'Sensor']

Here are all the available classes
- Light
- Categorical_sensor
- Humidity_sensor
- Air_conditioner
- Oven
- Coffee_machine
- Washing_machine
- Room
- Settable_device
- Temperature_sensor
- Numeric_sensor
- Device
- Occupancy_sensor
- Brightness_sensor
- Smoke_sensor
- Appliance
- Dimmable_light
- Togglable_device
- Robot_vacuum
- Boolean_sensor
- Television
- Sensor

These are the relationship types per labels
- (:Class)-[:SUBCLASSOF]->(:Class)
- (:NamedIndividual)-[:MEMBEROF]->(:Class)
- (:NamedIndividual)-[:LOCATED_IN]->(:NamedIndividual)
- (:Room)-[:CONTAINS]->(:NamedIndividual)
- (:NamedIndividual)-[:LOCATED_IN]->(:Room)
- (:NamedIndividual)-[:CONTAINS]->(:NamedIndividual)

where is the ceiling lamp 5? 


    You are a helpful smart assistant.
    You'll receive the results of the query, written in Cypher language: explain these results in a natural way.
    Please, be synthetic: read the results and explain them by answering to the user question.  
    

Comment the results of the Cypher query, in natural language: 
Original user question: "where is the ceiling lamp 5? "
Result from Neo4j: [{'r.name': 'Living_room'}]


    You are an expert Cypher generator: your task is to generate Cypher query that best answers the user question.
    
    Follow these guidelines:
    
    1. Always output a syntactically correct Cypher query and nothing else. 
    2. Use only the node labels, relationship types, and property keys provided in the schema.
    3. Use specific names only if explicitly mentioned in the question.
    4. Do not invent properties or overly specific details.
    5. Keep queries syntactically correct, simple, and readable.
    6. Access node properties using dot notation (e.g., `n.name`).
    
    
Here's the database schema:

These are values for the 'name' property
- Television_1
- Occupancy_sensor_4
- Occupancy_sensor_5
- Occupancy_sensor_2
- Washing_machine_1
- Occupancy_sensor_3
- Occupancy_sensor_1
- Study
- Temperature_sensor_1
- Ceiling_light_3
- Ceiling_light_2
- Ceiling_light_5
- Ceiling_light_4
- Ceiling_light_1
- Humidity_sensor_1
- Coffee_machine_1
- Lamp_1
- Kitchen
- Oven_1
- Bedroom
- Brightness_sensor_1
- Lamp_3
- Lamp_2
- Air_conditioner_1
- Air_conditioner_2
- Bathroom
- Smoke_sensor_1
- Robot_vacuum_1
- Living_room

Each label has these properties
Label: `NamedIndividual` has ONLY these properties: ['name', 'setting', 'state', 'unit', 'value']
Label: `Room` has ONLY these properties: ['name']
Label: `Class` has ONLY these properties: ['name']

Examples per Label
Examples for `NamedIndividual` -> ['Bathroom', 'Bedroom', 'Living_room', 'Robot_vacuum_1', 'Smoke_sensor_1']
Examples for `Room` -> ['Bathroom', 'Bedroom', 'Kitchen', 'Living_room', 'Study']
Examples for `Class` -> ['Appliance', 'Boolean_sensor', 'Dimmable_light', 'Robot_vacuum', 'Sensor']

Here are all the available classes
- Light
- Categorical_sensor
- Humidity_sensor
- Air_conditioner
- Oven
- Coffee_machine
- Washing_machine
- Room
- Settable_device
- Temperature_sensor
- Numeric_sensor
- Device
- Occupancy_sensor
- Brightness_sensor
- Smoke_sensor
- Appliance
- Dimmable_light
- Togglable_device
- Robot_vacuum
- Boolean_sensor
- Television
- Sensor

These are the relationship types per labels
- (:Class)-[:SUBCLASSOF]->(:Class)
- (:NamedIndividual)-[:MEMBEROF]->(:Class)
- (:NamedIndividual)-[:LOCATED_IN]->(:NamedIndividual)
- (:Room)-[:CONTAINS]->(:NamedIndividual)
- (:NamedIndividual)-[:LOCATED_IN]->(:Room)
- (:NamedIndividual)-[:CONTAINS]->(:NamedIndividual)

Check the temperature setting of all air conditioners.


    You are a helpful smart assistant.
    You'll receive the results of the query, written in Cypher language: explain these results in a natural way.
    Please, be synthetic: read the results and explain them by answering to the user question.  
    

Comment the results of the Cypher query, in natural language: 
Original user question: "Check the temperature setting of all air conditioners."
Result from Neo4j: [{'n.name': 'Air_conditioner_1', 'n.setting': [20]}, {'n.name': 'Air_conditioner_2', 'n.setting': [16]}]


    You are an expert Cypher generator: your task is to generate Cypher query that best answers the user question.
    
    Follow these guidelines:
    
    1. Always output a syntactically correct Cypher query and nothing else. 
    2. Use only the node labels, relationship types, and property keys provided in the schema.
    3. Use specific names only if explicitly mentioned in the question.
    4. Do not invent properties or overly specific details.
    5. Keep queries syntactically correct, simple, and readable.
    6. Access node properties using dot notation (e.g., `n.name`).
    
    
Here's the database schema:

These are values for the 'name' property
- Television_1
- Occupancy_sensor_4
- Occupancy_sensor_5
- Occupancy_sensor_2
- Washing_machine_1
- Occupancy_sensor_3
- Occupancy_sensor_1
- Study
- Temperature_sensor_1
- Ceiling_light_3
- Ceiling_light_2
- Ceiling_light_5
- Ceiling_light_4
- Ceiling_light_1
- Humidity_sensor_1
- Coffee_machine_1
- Lamp_1
- Kitchen
- Oven_1
- Bedroom
- Brightness_sensor_1
- Lamp_3
- Lamp_2
- Air_conditioner_1
- Air_conditioner_2
- Bathroom
- Smoke_sensor_1
- Robot_vacuum_1
- Living_room

Each label has these properties
Label: `NamedIndividual` has ONLY these properties: ['name', 'setting', 'state', 'unit', 'value']
Label: `Room` has ONLY these properties: ['name']
Label: `Class` has ONLY these properties: ['name']

Examples per Label
Examples for `NamedIndividual` -> ['Bathroom', 'Bedroom', 'Living_room', 'Robot_vacuum_1', 'Smoke_sensor_1']
Examples for `Room` -> ['Bathroom', 'Bedroom', 'Kitchen', 'Living_room', 'Study']
Examples for `Class` -> ['Appliance', 'Boolean_sensor', 'Dimmable_light', 'Robot_vacuum', 'Sensor']

Here are all the available classes
- Light
- Categorical_sensor
- Humidity_sensor
- Air_conditioner
- Oven
- Coffee_machine
- Washing_machine
- Room
- Settable_device
- Temperature_sensor
- Numeric_sensor
- Device
- Occupancy_sensor
- Brightness_sensor
- Smoke_sensor
- Appliance
- Dimmable_light
- Togglable_device
- Robot_vacuum
- Boolean_sensor
- Television
- Sensor

These are the relationship types per labels
- (:Class)-[:SUBCLASSOF]->(:Class)
- (:NamedIndividual)-[:MEMBEROF]->(:Class)
- (:NamedIndividual)-[:LOCATED_IN]->(:NamedIndividual)
- (:Room)-[:CONTAINS]->(:NamedIndividual)
- (:NamedIndividual)-[:LOCATED_IN]->(:Room)
- (:NamedIndividual)-[:CONTAINS]->(:NamedIndividual)

Is there any occupancy sensor indicating presence?
